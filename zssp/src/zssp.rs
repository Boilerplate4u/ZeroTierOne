/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * (c) ZeroTier, Inc.
 * https://www.zerotier.com/
 */

// ZSSP: ZeroTier Secure Session Protocol
// FIPS compliant Noise_XK with Jedi powers and built-in attack-resistant large payload (fragmentation) support.

use std::collections::HashMap;
use std::num::NonZeroU64;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{Arc, Mutex, RwLock, Weak};

use zerotier_crypto::aes::{Aes, AesCtr, AesGcm};
use zerotier_crypto::hash::{hmac_sha512, HMACSHA384, HMAC_SHA384_SIZE, SHA384};
use zerotier_crypto::p384::{P384KeyPair, P384PublicKey, P384_PUBLIC_KEY_SIZE};
use zerotier_crypto::secret::Secret;
use zerotier_crypto::{random, secure_eq};

use zerotier_utils::gatherarray::GatherArray;
use zerotier_utils::memory;
use zerotier_utils::ringbuffermap::RingBufferMap;
use zerotier_utils::unlikely_branch;

use pqc_kyber::{KYBER_SECRETKEYBYTES, KYBER_SSBYTES};

use crate::applicationlayer::ApplicationLayer;
use crate::constants::*;
use crate::error::Error;
use crate::proto::*;
use crate::sessionid::SessionId;

/// Session context for local application.
///
/// Each application using ZSSP must create an instance of this to own sessions and
/// defragment incoming packets that are not yet associated with a session.
pub struct Context<Application: ApplicationLayer> {
    initial_offer_defrag: Mutex<RingBufferMap<u64, GatherArray<Application::IncomingPacketBuffer, KEY_EXCHANGE_MAX_FRAGMENTS>, 1024, 256>>,
    sessions: RwLock<SessionMaps<Application>>,
}

/// Result generated by the context packet receive function, with possible payloads.
pub enum ReceiveResult<'b, Application: ApplicationLayer> {
    /// Packet was valid, but no action needs to be taken.
    Ok,

    /// Packet was valid and a data payload was decoded and authenticated.
    OkData(Arc<Session<Application>>, &'b mut [u8]),

    /// Packet was valid and a new session was created.
    OkNewSession(Arc<Session<Application>>),

    /// Packet appears valid but was ignored e.g. as a duplicate.
    Ignored,
}

/// ZeroTier Secure Session Protocol (ZSSP) Session
///
/// A FIPS/NIST compliant variant of Noise_XK with hybrid Kyber1024 PQ data forward secrecy.
pub struct Session<Application: ApplicationLayer> {
    /// This side's locally unique session ID
    pub id: SessionId,

    /// An arbitrary application defined object associated with each session
    pub application_data: Application::Data,

    psk: Secret<64>,
    send_counter: AtomicU64,
    receive_window: [AtomicU64; COUNTER_WINDOW_MAX_OOO],
    header_check_cipher: Aes,
    offer: Mutex<EphemeralOffer>,
    state: RwLock<State>,
    defrag: Mutex<RingBufferMap<u64, GatherArray<Application::IncomingPacketBuffer, MAX_FRAGMENTS>, 16, 16>>,
}

struct SessionMaps<Application: ApplicationLayer> {
    // Active sessions, automatically closed if the application no longer holds their Arc<>.
    active: HashMap<SessionId, Weak<Session<Application>>>,

    // Incomplete sessions in the middle of three-phase Noise_XK negotiation, expired after timeout.
    incomplete: HashMap<SessionId, Arc<NoiseXKIncoming>>,
}

struct NoiseXKIncoming {
    timestamp: i64,
    alice_session_id: SessionId,
    bob_session_id: SessionId,
    noise_es_ee: Secret<64>,
    hk: Secret<KYBER_SSBYTES>,
    header_check_cipher_key: Secret<AES_HEADER_CHECK_KEY_SIZE>,
    bob_noise_e_secret: P384KeyPair,
}

enum EphemeralOffer {
    None,
    NoiseXKInit(
        // boxed to discard memory after use since we only enter this state once at setup
        Box<(
            // alice_e_secret, metadata, noise_es, alice_hk_public, alice_hk_secret, header check key
            P384KeyPair,
            Option<Vec<u8>>,
            Secret<48>,
            Secret<KYBER_SECRETKEYBYTES>,
        )>,
    ),
    RekeyInit(P384KeyPair),
}

struct State {
    remote_session_id: Option<SessionId>,
    keys: [Option<SessionKey>; 2],
    current_key: usize,
}

struct SessionKey {
    receive_key: Secret<AES_KEY_SIZE>,            // Receive side AES-GCM key
    send_key: Secret<AES_KEY_SIZE>,               // Send side AES-GCM key
    receive_cipher_pool: Mutex<Vec<Box<AesGcm>>>, // Pool of reusable sending ciphers
    send_cipher_pool: Mutex<Vec<Box<AesGcm>>>,    // Pool of reusable receiving ciphers
    rekey_at_time: i64,                           // Rekey at or after this time (ticks)
    created_at_counter: u64,                      // Counter at which session was created
    rekey_at_counter: u64,                        // Rekey at or after this counter
    expire_at_counter: u64,                       // Hard error when this counter value is reached or exceeded
    confirmed: bool,                              // We have confirmed that the other side has this key
    role_is_bob: bool,                            // Was this side "Bob" in this exchange?
}

impl<Application: ApplicationLayer> Context<Application> {
    /// Create a new session context.
    pub fn new(_: &Application) -> Self {
        Self {
            initial_offer_defrag: Mutex::new(RingBufferMap::new(random::next_u32_secure())),
            sessions: RwLock::new(SessionMaps {
                active: HashMap::with_capacity(64),
                incomplete: HashMap::with_capacity(16),
            }),
        }
    }

    /// Perform periodic background service tasks.
    ///
    /// This returns the number of milliseconds until it should be called again. It performs
    /// tasks like cleaning up internal data structures.
    pub fn service(&self, current_time: i64) -> i64 {
        let mut dead_active = Vec::new();
        let mut dead_pending = Vec::new();

        {
            let sessions = self.sessions.read().unwrap();
            for (id, s) in sessions.active.iter() {
                if s.strong_count() == 0 {
                    dead_active.push(*id);
                }
            }
            for (id, p) in sessions.incomplete.iter() {
                if (p.timestamp - current_time) > INCOMPLETE_SESSION_TIMEOUT {
                    dead_pending.push(*id);
                }
            }
        }

        if !dead_active.is_empty() || !dead_pending.is_empty() {
            let mut sessions = self.sessions.write().unwrap();
            for id in dead_active.iter() {
                sessions.active.remove(id);
            }
            for id in dead_pending.iter() {
                sessions.incomplete.remove(id);
            }
        }

        INCOMPLETE_SESSION_TIMEOUT * 2
    }

    /// Create a new session and send initial packet(s) to other side.
    ///
    /// * `app` - Application layer instance
    /// * `send` - User-supplied packet sending function
    /// * `mtu` - Physical MTU for calls to send()
    /// * `local_session_id` - This side's session ID
    /// * `remote_s_public_blob` - Remote side's public key/identity blob
    /// * `metadata` - Optional metadata to be included in initial handshake
    /// * `psk` - Pre-shared key (use all zero if none)
    /// * `application_data` - Arbitrary opaque data to include with session object
    #[allow(unused_variables)]
    pub fn open<SendFunction: FnMut(&mut [u8])>(
        &self,
        app: &Application,
        mut send: SendFunction,
        mtu: usize,
        remote_s_public_blob: &[u8],
        metadata: Option<&[u8]>,
        psk: Secret<64>,
        application_data: Application::Data,
    ) -> Result<Arc<Session<Application>>, Error> {
        if let Some(md) = metadata.as_ref() {
            if md.len() > MAX_METADATA_SIZE {
                return Err(Error::DataTooLarge);
            }
        }

        if let Some(bob_s_public) = Application::extract_s_public_from_static_public_blob(remote_s_public_blob) {
            let alice_noise_e_secret = P384KeyPair::generate();
            let alice_noise_e = alice_noise_e_secret.public_key_bytes().clone();
            let noise_es = alice_noise_e_secret.agree(&bob_s_public).ok_or(Error::InvalidParameter)?;
            let alice_hk_secret = pqc_kyber::keypair(&mut random::SecureRandom::default());
            let header_check_cipher_key: [u8; AES_HEADER_CHECK_KEY_SIZE] = random::get_bytes_secure();

            let (local_session_id, session) = {
                let mut sessions = self.sessions.write().unwrap();

                let mut local_session_id;
                loop {
                    local_session_id = SessionId::random();
                    if !sessions.active.contains_key(&local_session_id) && !sessions.incomplete.contains_key(&local_session_id) {
                        break;
                    }
                }

                let session = Arc::new(Session {
                    id: local_session_id,
                    application_data,
                    psk,
                    send_counter: AtomicU64::new(2), // 1 is the counter value for this INIT message
                    receive_window: std::array::from_fn(|_| AtomicU64::new(0)),
                    header_check_cipher: Aes::new(&header_check_cipher_key),
                    offer: Mutex::new(EphemeralOffer::NoiseXKInit(Box::new((
                        alice_noise_e_secret,
                        metadata.map(|md| md.to_vec()),
                        noise_es.clone(),
                        Secret(alice_hk_secret.secret),
                    )))),
                    state: RwLock::new(State { remote_session_id: None, keys: [None, None], current_key: 0 }),
                    defrag: Mutex::new(RingBufferMap::new(random::xorshift64_random() as u32)),
                });

                sessions.active.insert(local_session_id, Arc::downgrade(&session));

                (local_session_id, session)
            };

            let mut init_buffer = [0u8; AliceNoiseXKInit::SIZE];
            let init: &mut AliceNoiseXKInit = byte_array_as_proto_buffer_mut(&mut init_buffer).unwrap();
            init.session_protocol_version = SESSION_PROTOCOL_VERSION;
            init.alice_noise_e = alice_noise_e;
            init.alice_session_id = *local_session_id.as_bytes();
            init.alice_hk_public = alice_hk_secret.public;
            init.header_check_cipher_key = header_check_cipher_key;

            let mut ctr = AesCtr::new(kbkdf::<AES_KEY_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_ENCRYPTION>(noise_es.as_bytes()).as_bytes());
            ctr.reset_set_iv(&alice_noise_e[P384_PUBLIC_KEY_SIZE - AES_CTR_NONCE_SIZE..]);
            ctr.crypt_in_place(&mut init_buffer[AliceNoiseXKInit::ENC_START..AliceNoiseXKInit::AUTH_START]);

            let hmac = hmac_sha384_2(
                kbkdf::<HMAC_SHA384_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_AUTHENTICATION>(noise_es.as_bytes()).as_bytes(),
                &create_message_nonce(PACKET_TYPE_ALICE_NOISE_XK_INIT, 1),
                &init_buffer[HEADER_SIZE..AliceNoiseXKInit::AUTH_START],
            );
            init_buffer[AliceNoiseXKInit::AUTH_START..AliceNoiseXKInit::AUTH_START + HMAC_SHA384_SIZE].copy_from_slice(&hmac);

            send_with_fragmentation(&mut send, &mut init_buffer, mtu, PACKET_TYPE_ALICE_NOISE_XK_INIT, None, 0, 1, None)?;

            return Ok(session);
        } else {
            return Err(Error::InvalidParameter);
        }
    }

    /// Receive, authenticate, decrypt, and process a physical wire packet.
    ///
    /// * `app` - Interface to application using ZSSP
    /// * `remote_address` - Remote physical address of source endpoint
    /// * `data_buf` - Buffer to receive decrypted and authenticated object data (an error is returned if too small)
    /// * `incoming_packet_buf` - Buffer containing incoming wire packet (receive() takes ownership)
    /// * `mtu` - Physical wire MTU for sending packets
    /// * `current_time` - Current monotonic time in milliseconds
    #[inline]
    pub fn receive<'b, SendFunction: FnMut(&mut [u8])>(
        &self,
        app: &Application,
        mut send: SendFunction,
        data_buf: &'b mut [u8],
        mut incoming_packet_buf: Application::IncomingPacketBuffer,
        mtu: usize,
        current_time: i64,
    ) -> Result<ReceiveResult<'b, Application>, Error> {
        let incoming_packet: &mut [u8] = incoming_packet_buf.as_mut();
        if incoming_packet.len() < MIN_PACKET_SIZE {
            unlikely_branch();
            return Err(Error::InvalidPacket);
        }

        let mut pending = None;
        if let Some(local_session_id) = SessionId::new_from_u64_le(memory::load_raw(incoming_packet)) {
            if let Some(session) = self.look_up_session(local_session_id) {
                session
                    .header_check_cipher
                    .decrypt_block_in_place(&mut incoming_packet[HEADER_CHECK_ENCRYPT_START..HEADER_CHECK_ENCRYPT_END]);
                let (key_index, packet_type, fragment_count, fragment_no, counter) = parse_packet_header(&incoming_packet);

                if session.check_receive_window(counter) {
                    if fragment_count > 1 {
                        if fragment_count <= (MAX_FRAGMENTS as u8) && fragment_no < fragment_count {
                            let mut defrag = session.defrag.lock().unwrap();
                            let fragment_gather_array = defrag.get_or_create_mut(&counter, || GatherArray::new(fragment_count));
                            if let Some(assembled_packet) = fragment_gather_array.add(fragment_no, incoming_packet_buf) {
                                drop(defrag); // release lock
                                return self.receive_complete(
                                    app,
                                    &mut send,
                                    data_buf,
                                    counter,
                                    assembled_packet.as_ref(),
                                    packet_type,
                                    Some(session),
                                    None,
                                    key_index,
                                    mtu,
                                    current_time,
                                );
                            } else {
                                return Ok(ReceiveResult::Ok);
                            }
                        } else {
                            unlikely_branch();
                            return Err(Error::InvalidPacket);
                        }
                    } else {
                        return self.receive_complete(
                            app,
                            &mut send,
                            data_buf,
                            counter,
                            &[incoming_packet_buf],
                            packet_type,
                            Some(session),
                            None,
                            key_index,
                            mtu,
                            current_time,
                        );
                    }
                } else {
                    unlikely_branch();
                    return Ok(ReceiveResult::Ignored);
                }
            } else {
                unlikely_branch();
                if let Some(p) = self.sessions.read().unwrap().incomplete.get(&local_session_id).cloned() {
                    Aes::new(p.header_check_cipher_key.as_bytes())
                        .decrypt_block_in_place(&mut incoming_packet[HEADER_CHECK_ENCRYPT_START..HEADER_CHECK_ENCRYPT_END]);
                    pending = Some(p);
                } else {
                    return Err(Error::UnknownLocalSessionId(local_session_id));
                }
            }
        } else {
            unlikely_branch();
        }

        let (key_index, packet_type, fragment_count, fragment_no, counter) = parse_packet_header(&incoming_packet);

        if fragment_count > 1 {
            let mut defrag = self.initial_offer_defrag.lock().unwrap();
            let fragment_gather_array = defrag.get_or_create_mut(&counter, || GatherArray::new(fragment_count));
            if let Some(assembled_packet) = fragment_gather_array.add(fragment_no, incoming_packet_buf) {
                drop(defrag); // release lock
                return self.receive_complete(
                    app,
                    &mut send,
                    data_buf,
                    counter,
                    assembled_packet.as_ref(),
                    packet_type,
                    None,
                    pending,
                    key_index,
                    mtu,
                    current_time,
                );
            }
        } else {
            return self.receive_complete(
                app,
                &mut send,
                data_buf,
                counter,
                &[incoming_packet_buf],
                packet_type,
                None,
                pending,
                key_index,
                mtu,
                current_time,
            );
        }

        return Ok(ReceiveResult::Ok);
    }

    /// Called internally when all fragments of a packet are received.
    ///
    /// NOTE: header check codes will already have been validated on receipt of each fragment. AEAD authentication
    /// and decryption has NOT yet been performed, and is done here.
    fn receive_complete<'b, SendFunction: FnMut(&mut [u8])>(
        &self,
        app: &Application,
        send: &mut SendFunction,
        data_buf: &'b mut [u8],
        counter: u64,
        fragments: &[Application::IncomingPacketBuffer],
        packet_type: u8,
        session: Option<Arc<Session<Application>>>,
        pending: Option<Arc<NoiseXKIncoming>>,
        key_index: usize,
        mtu: usize,
        current_time: i64,
    ) -> Result<ReceiveResult<'b, Application>, Error> {
        debug_assert!(fragments.len() >= 1);

        let message_nonce = create_message_nonce(packet_type, counter);
        if packet_type == PACKET_TYPE_DATA {
            if let Some(session) = session {
                let state = session.state.read().unwrap();
                if let Some(session_key) = state.keys[key_index].as_ref() {
                    let mut c = session_key.get_receive_cipher();
                    c.reset_init_gcm(&message_nonce);

                    let mut data_len = 0;

                    // Decrypt fragments 0..N-1 where N is the number of fragments.
                    for f in fragments[..(fragments.len() - 1)].iter() {
                        let f: &[u8] = f.as_ref();
                        debug_assert!(f.len() >= HEADER_SIZE);
                        let current_frag_data_start = data_len;
                        data_len += f.len() - HEADER_SIZE;
                        if data_len > data_buf.len() {
                            unlikely_branch();
                            session_key.return_receive_cipher(c);
                            return Err(Error::DataBufferTooSmall);
                        }
                        c.crypt(&f[HEADER_SIZE..], &mut data_buf[current_frag_data_start..data_len]);
                    }

                    // Decrypt final fragment (or only fragment if not fragmented)
                    let current_frag_data_start = data_len;
                    let last_fragment = fragments.last().unwrap().as_ref();
                    if last_fragment.len() < (HEADER_SIZE + AES_GCM_TAG_SIZE) {
                        unlikely_branch();
                        return Err(Error::InvalidPacket);
                    }
                    data_len += last_fragment.len() - (HEADER_SIZE + AES_GCM_TAG_SIZE);
                    if data_len > data_buf.len() {
                        unlikely_branch();
                        session_key.return_receive_cipher(c);
                        return Err(Error::DataBufferTooSmall);
                    }
                    let payload_end = last_fragment.len() - AES_GCM_TAG_SIZE;
                    c.crypt(
                        &last_fragment[HEADER_SIZE..payload_end],
                        &mut data_buf[current_frag_data_start..data_len],
                    );

                    let gcm_tag = &last_fragment[payload_end..];
                    let aead_authentication_ok = c.finish_decrypt(gcm_tag);
                    session_key.return_receive_cipher(c);

                    if aead_authentication_ok {
                        if session.update_receive_window(counter) {
                            // If the packet authenticated, this confirms that the other side indeed
                            // knows this session key. In that case mark the session key as confirmed
                            // and if the current active key is older switch it to point to this one.
                            if session_key.confirmed {
                                drop(state);
                            } else {
                                unlikely_branch();
                                let key_created_at_counter = session_key.created_at_counter;
                                drop(state);

                                let mut state = session.state.write().unwrap();
                                state.keys[key_index].as_mut().unwrap().confirmed = true;
                                if state.current_key != key_index {
                                    if let Some(other_session_key) = state.keys[state.current_key].as_ref() {
                                        if other_session_key.created_at_counter < key_created_at_counter {
                                            state.current_key = key_index;
                                        }
                                    } else {
                                        state.current_key = key_index;
                                    }
                                }
                            }

                            return Ok(ReceiveResult::OkData(session, &mut data_buf[..data_len]));
                        } else {
                            unlikely_branch();
                            return Ok(ReceiveResult::Ignored);
                        }
                    }
                }
                return Err(Error::FailedAuthentication);
            } else {
                unlikely_branch();
                return Err(Error::SessionNotEstablished);
            }
        } else {
            unlikely_branch();

            // For KEX packets go ahead and pre-assemble all fragments to simplify the code below.
            let mut pkt_assembly_buffer = [0u8; NOISE_MAX_HANDSHAKE_PACKET_SIZE];
            let pkt_assembled_size = assemble_fragments_into::<Application>(fragments, &mut pkt_assembly_buffer)?;
            if pkt_assembled_size < MIN_PACKET_SIZE {
                return Err(Error::InvalidPacket);
            }
            let pkt_assembled = &mut pkt_assembly_buffer[..pkt_assembled_size];
            if pkt_assembled[HEADER_SIZE] != SESSION_PROTOCOL_VERSION {
                return Err(Error::UnknownProtocolVersion);
            }

            match packet_type {
                PACKET_TYPE_ALICE_NOISE_XK_INIT => {
                    // Alice (remote) --> Bob (local)

                    /*
                     * This is the first message Bob receives from Alice, the initiator. It contains
                     * Alice's ephemeral keys but not her identity. Alice will not reveal her identity
                     * until forward secrecy is established and she's authenticated Bob.
                     *
                     * Bob authenticates the message and confirms that Alice indeed knows Bob's
                     * identity, then responds with his ephemeral keys.
                     *
                     * Bob also sends an opaque sealed object called Bob's "note to self." It contains
                     * Bob's state for the connection as of this first exchange, allowing Bob to be
                     * stateless until he knows and has confirmed Alice's identity. It's encrypted,
                     * authenticated, subject to a short TTL, and contains only information relevant
                     * to the current exchange.
                     */

                    // There shouldn't be a session yet on Bob's end, and this should be the first packet.
                    if session.is_some() || counter != 1 {
                        return Ok(ReceiveResult::Ignored);
                    }

                    let pkt: &AliceNoiseXKInit = byte_array_as_proto_buffer(pkt_assembled)?;

                    let alice_noise_e = P384PublicKey::from_bytes(&pkt.alice_noise_e).ok_or(Error::FailedAuthentication)?;
                    let noise_es = app.get_local_s_keypair().agree(&alice_noise_e).ok_or(Error::FailedAuthentication)?;

                    // Authenticate packet and prove that Alice knows our static public key.
                    if !secure_eq(
                        &pkt.hmac_es,
                        &hmac_sha384_2(
                            kbkdf::<HMAC_SHA384_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_AUTHENTICATION>(noise_es.as_bytes()).as_bytes(),
                            &message_nonce,
                            &pkt_assembled[HEADER_SIZE..AliceNoiseXKInit::AUTH_START],
                        ),
                    ) {
                        return Err(Error::FailedAuthentication);
                    }

                    // Decrypt encrypted part of payload (already authenticated above).
                    let mut ctr = AesCtr::new(kbkdf::<AES_KEY_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_ENCRYPTION>(noise_es.as_bytes()).as_bytes());
                    ctr.reset_set_iv(&SHA384::hash(&pkt.alice_noise_e)[..AES_CTR_NONCE_SIZE]);
                    ctr.crypt_in_place(&mut pkt_assembled[AliceNoiseXKInit::ENC_START..AliceNoiseXKInit::AUTH_START]);
                    let pkt: &AliceNoiseXKInit = byte_array_as_proto_buffer(pkt_assembled)?;

                    let alice_session_id = SessionId::new_from_bytes(&pkt.alice_session_id).ok_or(Error::InvalidPacket)?;

                    // Create Bob's ephemeral keys and derive noise_es_ee by agreeing with Alice's. Also create
                    // a Kyber ciphertext to send back to Alice.
                    let bob_noise_e_secret = P384KeyPair::generate();
                    let bob_noise_e = bob_noise_e_secret.public_key_bytes().clone();
                    let noise_es_ee = Secret(hmac_sha512(
                        noise_es.as_bytes(),
                        bob_noise_e_secret
                            .agree(&alice_noise_e)
                            .ok_or(Error::FailedAuthentication)?
                            .as_bytes(),
                    ));
                    let (bob_hk_ciphertext, hk) = pqc_kyber::encapsulate(&pkt.alice_hk_public, &mut random::SecureRandom::default())
                        .map_err(|_| Error::FailedAuthentication)
                        .map(|(ct, hk)| (ct, Secret(hk)))?;

                    // Pick a session ID for our side and save the intermediate ephemeral state for this exchange.
                    let bob_session_id = {
                        let mut sessions = self.sessions.write().unwrap();

                        let mut bob_session_id;
                        loop {
                            bob_session_id = SessionId::random();
                            if !sessions.active.contains_key(&bob_session_id) && !sessions.incomplete.contains_key(&bob_session_id) {
                                break;
                            }
                        }

                        if sessions.incomplete.len() >= INCOMPLETE_SESSION_MAX_QUEUE_SIZE {
                            // If this queue is too big, we remove the latest entry and replace it. The latest
                            // is used because under flood conditions this is most likely to be another bogus
                            // entry.
                            let mut newest = i64::MIN;
                            let mut newest_id = None;
                            for (id, s) in sessions.incomplete.iter() {
                                if s.timestamp >= newest {
                                    newest = s.timestamp;
                                    newest_id = Some(*id);
                                }
                            }
                            sessions.incomplete.remove(newest_id.as_ref().unwrap());
                        }

                        sessions.incomplete.insert(
                            bob_session_id,
                            Arc::new(NoiseXKIncoming {
                                timestamp: current_time,
                                alice_session_id,
                                bob_session_id,
                                noise_es_ee: noise_es_ee.clone(),
                                hk,
                                bob_noise_e_secret,
                                header_check_cipher_key: Secret(pkt.header_check_cipher_key),
                            }),
                        );

                        bob_session_id
                    };

                    // Create Bob's ephemeral counter-offer reply.
                    let mut reply_buffer = [0u8; BobNoiseXKAck::SIZE];
                    let reply: &mut BobNoiseXKAck = byte_array_as_proto_buffer_mut(&mut reply_buffer)?;
                    reply.session_protocol_version = SESSION_PROTOCOL_VERSION;
                    reply.bob_noise_e = bob_noise_e;
                    reply.bob_session_id = *bob_session_id.as_bytes();
                    reply.bob_hk_ciphertext = bob_hk_ciphertext;

                    // Encrypt main section of reply. Technically we could get away without this but why not?
                    let mut ctr =
                        AesCtr::new(kbkdf::<AES_KEY_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_ENCRYPTION>(noise_es_ee.as_bytes()).as_bytes());
                    ctr.reset_set_iv(&bob_noise_e[P384_PUBLIC_KEY_SIZE - AES_CTR_NONCE_SIZE..]);
                    ctr.crypt_in_place(&mut reply_buffer[BobNoiseXKAck::ENC_START..BobNoiseXKAck::AUTH_START]);

                    // Add HMAC-SHA384 to reply packet, allowing Alice to derive noise_es_ee and authenticate.
                    let reply_hmac = hmac_sha384_2(
                        kbkdf::<HMAC_SHA384_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_AUTHENTICATION>(noise_es_ee.as_bytes()).as_bytes(),
                        &create_message_nonce(PACKET_TYPE_BOB_NOISE_XK_ACK, 1),
                        &reply_buffer[HEADER_SIZE..BobNoiseXKAck::AUTH_START],
                    );
                    reply_buffer[BobNoiseXKAck::AUTH_START..].copy_from_slice(&reply_hmac);

                    send_with_fragmentation(
                        send,
                        &mut reply_buffer,
                        mtu,
                        PACKET_TYPE_BOB_NOISE_XK_ACK,
                        Some(alice_session_id),
                        0,
                        1,
                        Some(&Aes::new(&pkt.header_check_cipher_key)),
                    )?;

                    return Ok(ReceiveResult::Ok);
                }

                PACKET_TYPE_BOB_NOISE_XK_ACK => {
                    // Bob (remote) --> Alice (local)

                    /*
                     * This is Bob's reply to Alice's first message, allowing Alice to verify Bob's
                     * identity. Once this is done Alice can send her identity (encrypted) to complete
                     * the negotiation.
                     */

                    if counter != 1 {
                        return Ok(ReceiveResult::Ignored);
                    } else if let Some(session) = session {
                        match std::mem::replace(&mut *session.offer.lock().unwrap(), EphemeralOffer::None) {
                            EphemeralOffer::NoiseXKInit(mut boxed_offer) => {
                                let (alice_e_secret, metadata, noise_es, alice_hk_secret) = boxed_offer.as_mut();
                                let pkt: &BobNoiseXKAck = byte_array_as_proto_buffer(pkt_assembled)?;

                                if let Some(bob_session_id) = SessionId::new_from_bytes(&pkt.bob_session_id) {
                                    // Derive noise_es_ee from Bob's ephemeral public key.
                                    let bob_noise_e = P384PublicKey::from_bytes(&pkt.bob_noise_e).ok_or(Error::FailedAuthentication)?;
                                    let noise_es_ee = Secret(hmac_sha512(
                                        noise_es.as_bytes(),
                                        alice_e_secret.agree(&bob_noise_e).ok_or(Error::FailedAuthentication)?.as_bytes(),
                                    ));
                                    let noise_es_ee_kex_enc_key =
                                        kbkdf::<AES_KEY_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_ENCRYPTION>(noise_es_ee.as_bytes());
                                    let noise_es_ee_kex_hmac_key =
                                        kbkdf::<HMAC_SHA384_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_AUTHENTICATION>(noise_es_ee.as_bytes());

                                    // Authenticate Bob's reply and the validity of bob_noise_e.
                                    if !secure_eq(
                                        &pkt.hmac_es_ee,
                                        &hmac_sha384_2(
                                            noise_es_ee_kex_hmac_key.as_bytes(),
                                            &message_nonce,
                                            &pkt_assembled[HEADER_SIZE..BobNoiseXKAck::AUTH_START],
                                        ),
                                    ) {
                                        return Err(Error::FailedAuthentication);
                                    }

                                    // Decrypt encrypted portion of message.
                                    let mut ctr = AesCtr::new(noise_es_ee_kex_enc_key.as_bytes());
                                    ctr.reset_set_iv(&SHA384::hash(&pkt.bob_noise_e)[..AES_CTR_NONCE_SIZE]);
                                    ctr.crypt_in_place(&mut pkt_assembled[BobNoiseXKAck::ENC_START..BobNoiseXKAck::AUTH_START]);
                                    let pkt: &BobNoiseXKAck = byte_array_as_proto_buffer(pkt_assembled)?;

                                    // Complete Noise_XKpsk3 by mixing in noise_se followed by the PSK. The PSK as far as
                                    // the Noise pattern is concerned is the result of mixing the externally supplied PSK
                                    // with the Kyber1024 shared secret (hk). Kyber is treated as part of the PSK because
                                    // it's an external add-on beyond the Noise spec.
                                    let hk = pqc_kyber::decapsulate(&pkt.bob_hk_ciphertext, alice_hk_secret.as_bytes())
                                        .map_err(|_| Error::FailedAuthentication)
                                        .map(|k| Secret(k))?;
                                    let noise_es_ee_se_hk_psk = Secret(hmac_sha512(
                                        &hmac_sha512(
                                            noise_es_ee.as_bytes(),
                                            app.get_local_s_keypair()
                                                .agree(&bob_noise_e)
                                                .ok_or(Error::FailedAuthentication)?
                                                .as_bytes(),
                                        ),
                                        &hmac_sha512(session.psk.as_bytes(), hk.as_bytes()),
                                    ));

                                    let noise_es_ee_se_hk_psk_hmac_key = kbkdf::<HMAC_SHA384_SIZE, KBKDF_KEY_USAGE_LABEL_KEX_AUTHENTICATION>(
                                        noise_es_ee_se_hk_psk.as_bytes(),
                                    );

                                    // Authenticate entire key exchange.
                                    if !secure_eq(
                                        &pkt.hmac_es_ee_se_hk_psk,
                                        &hmac_sha384_2(
                                            noise_es_ee_se_hk_psk_hmac_key.as_bytes(),
                                            &message_nonce,
                                            &pkt_assembled[HEADER_SIZE..BobNoiseXKAck::AUTH_START + HMAC_SHA384_SIZE],
                                        ),
                                    ) {
                                        return Err(Error::FailedAuthentication);
                                    }

                                    let reply_counter = session.get_next_outgoing_counter().ok_or(Error::MaxKeyLifetimeExceeded)?;
                                    let reply_message_nonce = create_message_nonce(PACKET_TYPE_ALICE_NOISE_XK_ACK, reply_counter.get());

                                    // Create reply informing Bob of our static identity now that we've verified Bob and set
                                    // up forward secrecy. Also return Bob's opaque note.
                                    let mut reply_buffer = [0u8; NOISE_MAX_HANDSHAKE_PACKET_SIZE];
                                    reply_buffer[HEADER_SIZE] = SESSION_PROTOCOL_VERSION;
                                    let mut reply_len = HEADER_SIZE + 1;
                                    let mut reply_buffer_append = |b: &[u8]| {
                                        let reply_len_new = reply_len + b.len();
                                        reply_buffer[reply_len..reply_len_new].copy_from_slice(b);
                                        reply_len = reply_len_new;
                                    };
                                    let alice_s_public_blob = app.get_local_s_public_blob();
                                    assert!(alice_s_public_blob.len() <= (u16::MAX as usize));
                                    reply_buffer_append(&(alice_s_public_blob.len() as u16).to_le_bytes());
                                    reply_buffer_append(alice_s_public_blob);
                                    if let Some(md) = metadata.as_ref() {
                                        reply_buffer_append(&(md.len() as u16).to_le_bytes());
                                        reply_buffer_append(md.as_slice());
                                    } else {
                                        reply_buffer_append(&[0u8, 0u8]); // no meta-data
                                    }

                                    // Encrypt Alice's static identity and other inner payload items. The IV here
                                    // is a hash of 'hk' making it actually a secret and "borrowing" a little PQ
                                    // forward secrecy for Alice's identity.
                                    let mut ctr = AesCtr::new(noise_es_ee_kex_enc_key.as_bytes());
                                    ctr.reset_set_iv(&SHA384::hash(hk.as_bytes())[..AES_CTR_NONCE_SIZE]);
                                    ctr.crypt_in_place(&mut reply_buffer[HEADER_SIZE + 1..reply_len]);

                                    // First attach HMAC allowing Bob to verify that this is from the same Alice and to
                                    // verify the authenticity of encrypted data.
                                    let hmac_es_ee = hmac_sha384_2(
                                        noise_es_ee_kex_hmac_key.as_bytes(),
                                        &reply_message_nonce,
                                        &reply_buffer[HEADER_SIZE..reply_len],
                                    );
                                    reply_buffer[reply_len..reply_len + HMAC_SHA384_SIZE].copy_from_slice(&hmac_es_ee);
                                    reply_len += HMAC_SHA384_SIZE;

                                    // Then attach the final HMAC permitting Bob to verify the authenticity of the whole
                                    // key exchange. Bob won't be able to do this until he decrypts and parses Alice's
                                    // identity, so the first HMAC is to let him authenticate that first.
                                    let hmac_es_ee_se_hk_psk = hmac_sha384_2(
                                        noise_es_ee_se_hk_psk_hmac_key.as_bytes(),
                                        &reply_message_nonce,
                                        &reply_buffer[HEADER_SIZE..reply_len],
                                    );
                                    reply_buffer[reply_len..reply_len + HMAC_SHA384_SIZE].copy_from_slice(&hmac_es_ee_se_hk_psk);
                                    reply_len += HMAC_SHA384_SIZE;

                                    // Learn Bob's session ID and the first session key.
                                    {
                                        let mut state = session.state.write().unwrap();
                                        let _ = state.remote_session_id.insert(bob_session_id);
                                        let _ = state.keys[0].insert(SessionKey::new(
                                            noise_es_ee_se_hk_psk,
                                            current_time,
                                            reply_counter.get(),
                                            true,
                                            false,
                                        ));
                                        state.current_key = 0;
                                    }

                                    send_with_fragmentation(
                                        send,
                                        &mut reply_buffer[..reply_len],
                                        mtu,
                                        PACKET_TYPE_ALICE_NOISE_XK_ACK,
                                        Some(bob_session_id),
                                        0,
                                        reply_counter.get(),
                                        Some(&session.header_check_cipher),
                                    )?;

                                    return Ok(ReceiveResult::Ok);
                                } else {
                                    return Err(Error::InvalidPacket);
                                }
                            }
                            _ => return Ok(ReceiveResult::Ignored),
                        }
                    } else {
                        return Err(Error::SessionNotEstablished);
                    }
                }

                PACKET_TYPE_ALICE_NOISE_XK_ACK => {
                    // Alice (remote) --> Bob (local)

                    /*
                     * After negotiating a keyed session and Alice has had the opportunity to
                     * verify Bob, this is when Bob gets to learn who Alice is. At this point
                     * Bob can make a final decision about whether to keep talking to Alice
                     * and can create an actual session using the state memo-ized in the memo
                     * that Alice must return.
                     */

                    if session.is_some() {
                        return Ok(ReceiveResult::Ignored);
                    }

                    /*
                    // Restore state from note to self, returning to where we were after Alice's first contact.
                    let alice_session_id = SessionId::new_from_bytes(&bob_note_to_self.alice_session_id).ok_or(Error::InvalidPacket)?;
                    let bob_noise_e_secret = P384KeyPair::from_bytes(&bob_note_to_self.bob_noise_e, &bob_note_to_self.bob_noise_e_secret)
                        .ok_or(Error::InvalidPacket)?;
                    let hk = Secret(bob_note_to_self.hk);
                    let noise_es_ee = Secret(bob_note_to_self.noise_es_ee);
                    let header_check_cipher = Aes::new(&bob_note_to_self.header_check_cipher_key);
                    drop(bob_note_to_self_buffer);

                    // Authenticate packet with noise_es_ee (first HMAC) before decrypting and parsing static info.
                    let pkt_assembled_enc_end = pkt_assembled.len() - (HMAC_SHA384_SIZE * 2);
                    if !secure_eq(
                        &pkt_assembled[pkt_assembled_enc_end..pkt_assembled.len() - HMAC_SHA384_SIZE],
                        &hmac_sha384_2(
                            &kbkdf512(noise_es_ee.as_bytes(), KBKDF_KEY_USAGE_LABEL_KEX_AUTHENTICATION).as_bytes()[..HMAC_SHA384_SIZE],
                            &message_nonce,
                            &pkt_assembled[HEADER_SIZE..pkt_assembled_enc_end],
                        ),
                    ) {
                        return Err(Error::FailedAuthentication);
                    }

                    // Save a copy of the encrypted unmodified packet for final HMAC.
                    let mut pkt_saved_for_final_hmac = [0u8; NOISE_MAX_HANDSHAKE_PACKET_SIZE];
                    pkt_saved_for_final_hmac[..pkt_assembled.len()].copy_from_slice(pkt_assembled);

                    // Decrypt Alice's static identity and decode.
                    let mut ctr =
                        AesCtr::new(&kbkdf512(noise_es_ee.as_bytes(), KBKDF_KEY_USAGE_LABEL_KEX_ENCRYPTION).as_bytes()[..AES_KEY_SIZE]);
                    ctr.reset_set_iv(&SHA384::hash(hk.as_bytes())[..AES_CTR_NONCE_SIZE]);
                    ctr.crypt_in_place(&mut pkt_assembled[ALICE_NOISE_XK_ACK_ENC_START..pkt_assembled_enc_end]);

                    let mut alice_static_info = &pkt_assembled[ALICE_NOISE_XK_ACK_ENC_START..pkt_assembled_enc_end];
                    if alice_static_info.len() < 2 {
                        return Err(Error::InvalidPacket);
                    }
                    let alice_static_public_blob_len = u16::from_le_bytes(alice_static_info[..2].try_into().unwrap()) as usize;
                    alice_static_info = &alice_static_info[2..];
                    if alice_static_info.len() < alice_static_public_blob_len {
                        return Err(Error::InvalidPacket);
                    }
                    let alice_static_public_blob = &alice_static_info[..alice_static_public_blob_len];
                    alice_static_info = &alice_static_info[alice_static_public_blob_len..];
                    if alice_static_info.len() < 2 {
                        return Err(Error::InvalidPacket);
                    }
                    let meta_data_len = u16::from_le_bytes(alice_static_info[..2].try_into().unwrap()) as usize;
                    alice_static_info = &alice_static_info[2..];
                    if alice_static_info.len() < meta_data_len {
                        return Err(Error::InvalidPacket);
                    }
                    let meta_data = &alice_static_info[..meta_data_len];

                    if let Some((bob_session_id, psk, app_data)) =
                        app.accept_new_session(self, remote_address, alice_static_public_blob, meta_data)
                    {
                        // Create final Noise_XKpsk3 shared secret on this side.
                        let noise_es_ee_se_hk_psk = Secret(hmac_sha512(
                            &hmac_sha512(
                                noise_es_ee.as_bytes(),
                                bob_noise_e_secret
                                    .agree(
                                        &Application::extract_s_public_from_raw(alice_static_public_blob)
                                            .ok_or(Error::FailedAuthentication)?,
                                    )
                                    .ok_or(Error::FailedAuthentication)?
                                    .as_bytes(),
                            ),
                            &hmac_sha512(psk.as_bytes(), hk.as_bytes()),
                        ));

                        // Final authentication with the whole enchelada.
                        if !secure_eq(
                            &pkt_assembled[pkt_assembled_enc_end + HMAC_SHA384_SIZE..],
                            &hmac_sha384_2(
                                &kbkdf512(noise_es_ee_se_hk_psk.as_bytes(), KBKDF_KEY_USAGE_LABEL_KEX_AUTHENTICATION).as_bytes()
                                    [..HMAC_SHA384_SIZE],
                                &message_nonce,
                                &pkt_saved_for_final_hmac[HEADER_SIZE..pkt_assembled_enc_end + HMAC_SHA384_SIZE],
                            ),
                        ) {
                            return Err(Error::FailedAuthentication);
                        }

                        return Ok(ReceiveResult::OkNewSession(Arc::new(Session {
                            id: bob_session_id,
                            application_data: app_data,
                            psk,
                            send_counter: AtomicU64::new(2), // 1 was already used in our first reply
                            receive_window: std::array::from_fn(|_| AtomicU64::new(0)),
                            header_check_cipher,
                            offer: Mutex::new(EphemeralOffer::None),
                            state: RwLock::new(State {
                                remote_session_id: Some(alice_session_id),
                                keys: [Some(SessionKey::new(noise_es_ee_se_hk_psk, current_time, 2, true, true)), None],
                                current_key: 0,
                            }),
                            defrag: Mutex::new(RingBufferMap::new(random::xorshift64_random() as u32)),
                        })));
                    } else {
                        return Err(Error::NewSessionRejected);
                    }
                    */
                    todo!()
                }

                PACKET_TYPE_ALICE_REKEY_INIT => todo!(),

                PACKET_TYPE_BOB_REKEY_ACK => todo!(),

                _ => {
                    return Err(Error::InvalidPacket);
                }
            }
        }
    }

    /// Look up a session by local session ID.
    fn look_up_session(&self, id: SessionId) -> Option<Arc<Session<Application>>> {
        self.sessions.read().unwrap().active.get(&id).and_then(|s| s.upgrade())
    }
}

impl<Application: ApplicationLayer> Session<Application> {
    /// Send data over the session.
    ///
    /// * `send` - Function to call to send physical packet(s)
    /// * `mtu_sized_buffer` - A writable work buffer whose size also specifies the physical MTU
    /// * `data` - Data to send
    #[inline]
    pub fn send<SendFunction: FnMut(&mut [u8])>(
        &self,
        mut send: SendFunction,
        mtu_sized_buffer: &mut [u8],
        mut data: &[u8],
    ) -> Result<(), Error> {
        debug_assert!(mtu_sized_buffer.len() >= MIN_TRANSPORT_MTU);
        let state = self.state.read().unwrap();
        if let Some(remote_session_id) = state.remote_session_id {
            if let Some(session_key) = state.keys[state.current_key].as_ref() {
                let counter = self.send_counter.fetch_add(1, Ordering::SeqCst);

                let mut c = session_key.get_send_cipher(counter)?;
                c.reset_init_gcm(&create_message_nonce(PACKET_TYPE_DATA, counter));

                let fragment_count =
                    (((data.len() + AES_GCM_TAG_SIZE) as f32) / (mtu_sized_buffer.len() - HEADER_SIZE) as f32).ceil() as usize;
                let fragment_max_chunk_size = mtu_sized_buffer.len() - HEADER_SIZE;
                let last_fragment_no = fragment_count - 1;
                for fragment_no in 0..fragment_count {
                    let chunk_size = fragment_max_chunk_size.min(data.len());
                    let mut fragment_size = chunk_size + HEADER_SIZE;
                    set_packet_header(
                        mtu_sized_buffer,
                        fragment_count,
                        fragment_no,
                        PACKET_TYPE_DATA,
                        u64::from(remote_session_id),
                        state.current_key,
                        counter,
                    )?;
                    c.crypt(&data[..chunk_size], &mut mtu_sized_buffer[HEADER_SIZE..fragment_size]);
                    data = &data[chunk_size..];
                    if fragment_no == last_fragment_no {
                        debug_assert!(data.is_empty());
                        let tagged_fragment_size = fragment_size + AES_GCM_TAG_SIZE;
                        mtu_sized_buffer[fragment_size..tagged_fragment_size].copy_from_slice(&c.finish_encrypt());
                        fragment_size = tagged_fragment_size;
                    }
                    self.header_check_cipher
                        .encrypt_block_in_place(&mut mtu_sized_buffer[HEADER_CHECK_ENCRYPT_START..HEADER_CHECK_ENCRYPT_END]);
                    send(&mut mtu_sized_buffer[..fragment_size]);
                }
                debug_assert!(data.is_empty());

                session_key.return_send_cipher(c);

                return Ok(());
            } else {
                unlikely_branch();
            }
        }
        return Err(Error::SessionNotEstablished);
    }

    /// Check whether this session is established.
    pub fn established(&self) -> bool {
        let state = self.state.read().unwrap();
        state.keys[state.current_key].is_some()
    }

    /// Get the next outgoing counter value.
    #[inline(always)]
    fn get_next_outgoing_counter(&self) -> Option<NonZeroU64> {
        NonZeroU64::new(self.send_counter.fetch_add(1, Ordering::SeqCst))
    }

    /// Check the receive window without mutating state.
    #[inline(always)]
    fn check_receive_window(&self, counter: u64) -> bool {
        let c = self.receive_window[(counter as usize) % COUNTER_WINDOW_MAX_OOO].load(Ordering::Acquire);
        c < counter && counter.wrapping_sub(c) < COUNTER_WINDOW_MAX_SKIP_AHEAD
    }

    /// Update the receive window, returning true if the packet is still valid.
    /// This should only be called after the packet is authenticated.
    #[inline(always)]
    fn update_receive_window(&self, counter: u64) -> bool {
        let c = self.receive_window[(counter as usize) % COUNTER_WINDOW_MAX_OOO].fetch_max(counter, Ordering::AcqRel);
        c < counter && counter.wrapping_sub(c) < COUNTER_WINDOW_MAX_SKIP_AHEAD
    }
}

fn set_packet_header(
    packet: &mut [u8],
    fragment_count: usize,
    fragment_no: usize,
    packet_type: u8,
    recipient_session_id: u64,
    key_index: usize,
    counter: u64,
) -> Result<(), Error> {
    debug_assert!(packet.len() >= MIN_PACKET_SIZE);
    debug_assert!(fragment_count > 0);
    debug_assert!(fragment_no < MAX_FRAGMENTS);
    debug_assert!(packet_type <= 0x0f); // packet type is 4 bits
    if fragment_count <= MAX_FRAGMENTS {
        // [0-47]            recipient session ID
        // -- start of header check cipher single block encrypt --
        // [48-48]           key index (least significant bit)
        // [49-51]           packet type (0-15)
        // [52-57]           fragment count (1..64 - 1, so 0 means 1 fragment)
        // [58-63]           fragment number (0..63)
        // [64-127]          64-bit counter
        memory::store_raw(
            (u64::from(recipient_session_id)
                | ((key_index & 1) as u64).wrapping_shl(48)
                | (packet_type as u64).wrapping_shl(49)
                | ((fragment_count - 1) as u64).wrapping_shl(52)
                | (fragment_no as u64).wrapping_shl(58))
            .to_le(),
            packet,
        );
        memory::store_raw(counter.to_le(), &mut packet[8..]);
        Ok(())
    } else {
        unlikely_branch();
        Err(Error::DataTooLarge)
    }
}

#[inline(always)]
fn parse_packet_header(incoming_packet: &[u8]) -> (usize, u8, u8, u8, u64) {
    let raw_header_a = u16::from_le(memory::load_raw(&incoming_packet[6..]));
    let key_index = (raw_header_a & 1) as usize;
    let packet_type = (raw_header_a.wrapping_shr(1) & 7) as u8;
    let fragment_count = ((raw_header_a.wrapping_shr(4) & 63) + 1) as u8;
    let fragment_no = raw_header_a.wrapping_shr(10) as u8;
    let counter = u64::from_le(memory::load_raw(&incoming_packet[8..]));
    (key_index, packet_type, fragment_count, fragment_no, counter)
}

#[derive(Clone, Copy)]
#[repr(C, packed)]
struct MessageNonce(u64, u32);

/// Create a 96-bit AES-GCM nonce.
///
/// The primary information that we want to be contained here is the counter and the
/// packet type. The former makes this unique and the latter's inclusion authenticates
/// it as effectively AAD. Other elements of the header are either not authenticated,
/// like fragmentation info, or their authentication is implied via key exchange like
/// the session ID.
///
/// This is also used as part of HMAC authentication for key exchange packets.
#[inline(always)]
fn create_message_nonce(packet_type: u8, counter: u64) -> [u8; AES_GCM_NONCE_SIZE] {
    memory::to_byte_array(MessageNonce(counter.to_le(), (packet_type as u32).to_le()))
}

/// Break a packet into fragments and send them all.
/// The contents of packet[] are mangled during this operation, so it should be discarded after.
fn send_with_fragmentation<SendFunction: FnMut(&mut [u8])>(
    send: &mut SendFunction,
    packet: &mut [u8],
    mtu: usize,
    packet_type: u8,
    recipient_session_id: Option<SessionId>,
    key_index: usize,
    counter: u64,
    header_check_cipher: Option<&Aes>,
) -> Result<(), Error> {
    let packet_len = packet.len();
    let recipient_session_id = recipient_session_id.map_or(SessionId::NONE, |s| u64::from(s));
    let fragment_count = ((packet_len as f32) / (mtu as f32)).ceil() as usize;
    let mut fragment_start = 0;
    let mut fragment_end = packet_len.min(mtu);
    for fragment_no in 0..fragment_count {
        let fragment = &mut packet[fragment_start..fragment_end];
        set_packet_header(
            fragment,
            fragment_count,
            fragment_no,
            packet_type,
            recipient_session_id,
            key_index,
            counter,
        )?;
        if let Some(hcc) = header_check_cipher {
            hcc.encrypt_block_in_place(&mut fragment[6..22]);
        }
        send(fragment);
        fragment_start = fragment_end - HEADER_SIZE;
        fragment_end = (fragment_start + mtu).min(packet_len);
    }
    Ok(())
}

impl SessionKey {
    fn new(key: Secret<64>, current_time: i64, current_counter: u64, confirmed: bool, role_is_bob: bool) -> Self {
        let a2b = kbkdf::<AES_KEY_SIZE, KBKDF_KEY_USAGE_LABEL_AES_GCM_ALICE_TO_BOB>(key.as_bytes());
        let b2a = kbkdf::<AES_KEY_SIZE, KBKDF_KEY_USAGE_LABEL_AES_GCM_BOB_TO_ALICE>(key.as_bytes());
        let (receive_key, send_key) = if role_is_bob {
            (a2b, b2a)
        } else {
            (b2a, a2b)
        };
        Self {
            receive_key,
            send_key,
            receive_cipher_pool: Mutex::new(Vec::with_capacity(2)),
            send_cipher_pool: Mutex::new(Vec::with_capacity(2)),
            rekey_at_time: current_time
                .checked_add(REKEY_AFTER_TIME_MS + ((random::xorshift64_random() as u32) % REKEY_AFTER_TIME_MS_MAX_JITTER) as i64)
                .unwrap(),
            created_at_counter: current_counter,
            rekey_at_counter: current_counter.checked_add(REKEY_AFTER_USES).unwrap(),
            expire_at_counter: current_counter.checked_add(EXPIRE_AFTER_USES).unwrap(),
            confirmed,
            role_is_bob,
        }
    }

    fn get_send_cipher(&self, counter: u64) -> Result<Box<AesGcm>, Error> {
        if counter < self.expire_at_counter {
            Ok(self
                .send_cipher_pool
                .lock()
                .unwrap()
                .pop()
                .unwrap_or_else(|| Box::new(AesGcm::new(self.send_key.as_bytes(), true))))
        } else {
            unlikely_branch();

            // Not only do we return an error, but we also destroy the key.
            let mut scp = self.send_cipher_pool.lock().unwrap();
            scp.clear();
            self.send_key.nuke();

            Err(Error::MaxKeyLifetimeExceeded)
        }
    }

    fn return_send_cipher(&self, c: Box<AesGcm>) {
        self.send_cipher_pool.lock().unwrap().push(c);
    }

    fn get_receive_cipher(&self) -> Box<AesGcm> {
        self.receive_cipher_pool
            .lock()
            .unwrap()
            .pop()
            .unwrap_or_else(|| Box::new(AesGcm::new(self.receive_key.as_bytes(), false)))
    }

    fn return_receive_cipher(&self, c: Box<AesGcm>) {
        self.receive_cipher_pool.lock().unwrap().push(c);
    }
}

/// Shortcut to HMAC data split into two slices.
fn hmac_sha384_2(key: &[u8], a: &[u8], b: &[u8]) -> [u8; 48] {
    let mut hmac = HMACSHA384::new(key);
    hmac.update(a);
    hmac.update(b);
    hmac.finish()
}

/// HMAC-SHA512 key derivation based on: https://csrc.nist.gov/publications/detail/sp/800-108/final (page 7)
/// Cryptographically this isn't meaningfully different from HMAC(key, [label]) but this is how NIST rolls.
fn kbkdf<const OUTPUT_BYTES: usize, const LABEL: u8>(key: &[u8]) -> Secret<OUTPUT_BYTES> {
    //These are the values we have assigned to the 5 variables involved in https://csrc.nist.gov/publications/detail/sp/800-108/final:
    // K_in = key, [i]_2 = 0x01, Label = 'Z'||'T'||label, Context = 0x00, L = 0x0200
    Secret::<OUTPUT_BYTES>::from_bytes(
        &hmac_sha512(
            key,
            &[
                1,
                b'Z',
                b'T',
                LABEL,
                0x00,
                0,
                (((OUTPUT_BYTES * 8) >> 8) & 0xff) as u8,
                ((OUTPUT_BYTES * 8) & 0xff) as u8,
            ],
        )[..OUTPUT_BYTES],
    )
}
